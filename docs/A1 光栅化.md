- 现代 GPU 实现了一种名为**光栅化流水线**（Rasterization Pipeline）的抽象概念。这一抽象将**三维三角形转换为二维像素**的过程分成几个高度并行的阶段，从而实现了各种高效的硬件实现。在本作业中，您将在软件中实现简化光栅化流水线的部分功能。虽然经过简化，但您的管道将足以让 Scotty3D 在没有 GPU 的情况下创建预览渲染！

- 不同的图形应用程序接口可能会以不同的方式呈现这一流水线，但其核心步骤是一致的：
  - GPU 通过在顶点列表上运行代码（并行）来绘制图形，以产生均匀的屏幕位置（+ 额外的变化数据），
  - 从顶点列表中构建三角形，
  - 剪切clipping三角形以移除屏幕上不可见的部分，
  - 执行分割division以计算屏幕位置，
  - 计算这些三角形覆盖的片元 "fragments" 列表，
  - 在每个片元上运行代码，并将结果合成到帧缓冲区framebuffer中。
- **重要**：在开始之前，请阅读 src/rasterizer/pipeline.h，以了解我们的代码是如何实现这一流水线的。熟悉本作业中经常提到的术语，如像素、片元、属性和样本。您将在 src/rasterizer/pipeline.cpp（以及其他几个文件）中填写函数，以完成此实现。

## A1T1 Scene Functions

您的第一项任务是在 Scotty3D 中完成scene graph的实现，在 Transform 类（用于表示对象位置）中填写两个函数。

正如我们在三维变换讲座中所讨论的，Scotty3D 使用场景图来表示场景中物体的位置。

我们的场景图（src/scene/scene.h）使用 Transform 对象（src/scene/transform.h）来**表示对象空间和世界空间之间的转换**，这些对象记录了从对象本地位置移动到相对于每个对象的父对象的位置时必须应用的**缩放、旋转和平移**（按此顺序！）。

- 事实上，`Transform::local_to_parent` 可以方便地将这些变换返回为一个 4x4 矩阵 (Mat4)。

你的工作就是填写 Transform::local_to_world 和 Transform::world_to_local 这两个函数，它们返回的 Mat4 表示从对象空间到/从世界空间的变换。

### Anwser

- `local_to_world` 就是求从本地坐标变换到世界坐标的矩阵
- `world_to_local`就是反过来
- 要注意的点是矩阵是从右往左一次应用，区分开即可

```c++
Mat4 Transform::local_to_world() const {
	// A1T1: local_to_world
	//don't use Mat4::inverse() in your code.

	if (std::shared_ptr<Transform> parent_ = parent.lock()) {
		//此时该transform有parent
		return  parent_->local_to_world() * local_to_parent();
	} else {
		// 没有parent
		return local_to_parent();
	}
}

Mat4 Transform::world_to_local() const {
	// A1T1: world_to_local
	//don't use Mat4::inverse() in your code.
	
	if (std::shared_ptr<Transform> parent_ = parent.lock()) {
		//此时该transform有parent
		return  parent_to_local() * parent_->world_to_local();
	} else {
		// 没有parent
		return parent_to_local();
	}
}
```













































































































































































